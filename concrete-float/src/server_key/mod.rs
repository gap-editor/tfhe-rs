//! Module with the definition of the ServerKey.
//!
//! This module implements the generation of the server public key, together with all the
//! available homomorphic integer operations.
mod add;
mod align_mantissa;
mod division;
mod mul;
mod relu;
mod sigmoid;
mod sub;
mod tools;

#[cfg(test)]
mod tests;

use tfhe::shortint;

use crate::ciphertext::Ciphertext;
use crate::client_key::ClientKey;
use serde::{Deserialize, Serialize};
use shortint::ciphertext::{Degree, MaxDegree};

/// Error returned when the carry buffer is full.
pub use shortint::CheckError;

/// A structure containing the server public key.
///
/// The server key is generated by the client and is meant to be published: the client
/// sends it to the server so it can compute homomorphic integer circuits.
#[derive(Serialize, Deserialize, Clone)]
pub struct ServerKey {
    pub key: shortint::server_key::ServerKey,
    pub integer_key: tfhe::integer::server_key::ServerKey,
    pub wopbs_key: shortint::wopbs::WopbsKey,
}

impl ServerKey {
    /// Generates a server key.
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_float::parameters::{PARAM_MESSAGE_2_CARRY_2_32, WOP_PARAM_MESSAGE_2_CARRY_2_32};
    /// use concrete_float::{ClientKey, ServerKey};
    /// //mantissa and exponent defined over 4 blocks    ///
    /// let size_mantissa = 4;
    /// let size_exponent = 2;
    ///
    /// // Generate the client key:
    /// let param = (PARAM_MESSAGE_2_CARRY_2_32, WOP_PARAM_MESSAGE_2_CARRY_2_32);
    /// let cks = ClientKey::new(param, size_mantissa, size_exponent);
    ///
    /// // Generate the server key:
    /// let sks = ServerKey::new(&cks);
    /// ```
    pub fn new(cks: &ClientKey) -> ServerKey {
        // It should remain just enough space to add a carry
        let max =
            (cks.key.parameters.message_modulus().0 - 1) * cks.key.parameters.carry_modulus().0 - 1;
        let key =
            shortint::server_key::ServerKey::new_with_max_degree(&cks.key, MaxDegree::new(max));
        let integer_key = tfhe::integer::server_key::ServerKey::from_shortint_ex(key.clone());
        let wopbs_key =
            shortint::wopbs::WopbsKey::new_wopbs_key_only_for_wopbs(&cks.key, &key.clone());
        ServerKey {
            key,
            integer_key,
            wopbs_key,
        }
    }

    /// Create a ciphertext filled with zeros
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_float::gen_keys;
    /// use concrete_shortint::parameters::DEFAULT_PARAMETERS;
    ///
    /// let size_mantissa = 4;
    /// let size_exponent = 4;
    /// let e_min = -2;
    /// // Generate the client key and the server key:
    /// let (cks, sks) = gen_keys(&DEFAULT_PARAMETERS, size, size);
    ///
    /// let ctxt = sks.create_trivial_zero(size_mantissa, size_exponent, e_min, vec![]);
    ///
    /// // Decrypt:
    /// let dec = cks.decrypt(&ctxt);
    /// assert_eq!(0, dec);
    /// ```
    pub fn create_trivial_zero(
        &self,
        size_mantissa: usize,
        size_exponent: usize,
        e_min: i64,
    ) -> Ciphertext {
        let mut vec_res_mantissa = Vec::<shortint::Ciphertext>::with_capacity(size_mantissa);
        let mut zero = self.key.create_trivial(0_u64);
        zero.degree = Degree::new(0);
        for _ in 0..size_mantissa {
            vec_res_mantissa.push(zero.clone());
        }

        let mut vec_res_exponent = Vec::<shortint::Ciphertext>::with_capacity(size_exponent);
        for _ in 0..size_exponent {
            vec_res_exponent.push(zero.clone());
        }

        let sign = zero;

        Ciphertext {
            ct_vec_mantissa: vec_res_mantissa,
            ct_vec_exponent: vec_res_exponent,
            ct_sign: sign,
            e_min,
        }
    }

    pub fn create_trivial_zero_from_ct(&self, ctxt: &Ciphertext) -> Ciphertext {
        self.create_trivial_zero(
            ctxt.ct_vec_mantissa.len(),
            ctxt.ct_vec_exponent.len(),
            ctxt.e_min,
        )
    }

    /// Propagate the carry of the 'index' block to the next one.
    /// if index is equals to the MS LWE, this operation do nothing.
    /// We want to keep all the information on this LWE ( with this operation we can't create a
    /// new LWE
    pub fn propagate_mantissa(&self, ctxt: &mut [shortint::Ciphertext], index: usize) {
        if index < ctxt.len() - 1 {
            let carry = self.key.carry_extract(&ctxt[index]);
            ctxt[index] = self.key.message_extract(&ctxt[index]);
            self.key.unchecked_add_assign(&mut ctxt[index + 1], &carry);
        }
        //TODO maybe just BS to decrease the noise ?
    }

    /// Propagate all the carries.
    pub fn full_propagate_mantissa(&self, ctxt: &mut [shortint::Ciphertext]) {
        let len = ctxt.len();
        for i in 0..len {
            self.propagate_mantissa(ctxt, i);
        }
    }

    pub fn propagate_exponent(&self, ctxt: &mut Vec<shortint::Ciphertext>, index: usize) {
        if index < ctxt.len() - 1 {
            let carry = self.key.carry_extract(&ctxt[index]);
            ctxt[index] = self.key.message_extract(&ctxt[index]);
            self.key.unchecked_add_assign(&mut ctxt[index + 1], &carry);
        } else {
            ctxt[index] = self.key.message_extract(&ctxt[index]);
        }
    }

    /// Propagate all the carries.
    /// except the msb lwe
    pub fn partial_propagate(&self, ctxt: &mut Vec<shortint::Ciphertext>) {
        for i in 0..(ctxt.len() - 1) {
            self.propagate_exponent(ctxt, i);
        }
    }

    /// Propagate all the carries.
    pub fn full_propagate_exponent(&self, ctxt: &mut Vec<shortint::Ciphertext>) {
        for i in 0..(ctxt.len()) {
            self.propagate_exponent(ctxt, i);
        }
    }

    /// boolean bootstrapping
    pub fn reduce_noise_sign(&self, ctxt: &mut Ciphertext) {
        let msg_modulus = ctxt.ct_sign.message_modulus.0 as u64;
        let car_modulus = ctxt.ct_sign.carry_modulus.0 as u64;
        let msg_space = msg_modulus * car_modulus;
        self.key
            .unchecked_scalar_add_assign(&mut ctxt.ct_sign, (msg_space / 2) as u8);
        let accumulator = self
            .key
            .generate_lookup_table(|x| (x & (msg_space / 2)).wrapping_neg());
        //self.key.keyswitch_programmable_bootstrap_assign(&mut ctxt.ct_sign, &accumulator);
        self.key
            .apply_lookup_table_assign(&mut ctxt.ct_sign, &accumulator);
        self.key
            .unchecked_scalar_add_assign(&mut ctxt.ct_sign, (msg_space / 2) as u8);
        // We can always add as the sign is managed on the padding bit, the only important thing is
        // the noise
        ctxt.ct_sign.degree = Degree::new(0);
    }

    fn propagate_mantissa_increase_exponent_if_necessary(
        &self,
        ctxt: &mut Ciphertext,
        index: usize,
    ) {
        if index < ctxt.ct_vec_mantissa.len() - 1 {
            let carry = self.key.carry_extract(&ctxt.ct_vec_mantissa[index]);
            ctxt.ct_vec_mantissa[index] = self.key.message_extract(&ctxt.ct_vec_mantissa[index]);
            self.key
                .unchecked_add_assign(&mut ctxt.ct_vec_mantissa[index + 1], &carry);
        } else {
            self.increase_exponent_if_necessary(ctxt);
        }
    }

    fn increase_exponent_if_necessary(&self, ctxt: &mut Ciphertext) {
        let msg_modulus = self.wopbs_key.param.message_modulus.0 as usize;
        let car_modulus = self.wopbs_key.param.carry_modulus.0 as usize;
        let msg_space = f64::log2((msg_modulus * car_modulus) as f64) as usize;
        let len = ctxt.ct_vec_mantissa.len();
        let carry = self
            .key
            .carry_extract(&ctxt.ct_vec_mantissa.last().unwrap());
        ctxt.ct_vec_mantissa[len - 1] = self
            .key
            .message_extract(&ctxt.ct_vec_mantissa.last().clone().unwrap());
        let mut tmp = ctxt.clone();
        tmp.ct_vec_mantissa.push(carry.clone());
        let _ = tmp.ct_vec_mantissa.remove(0);
        self.key
            .unchecked_scalar_add_assign(&mut tmp.ct_vec_exponent[0], 1);
        let ggsw_carry = self.ggsw_pbs_ks_cbs(&carry, msg_space);
        let res = self.cmuxes_full(ctxt, &tmp, &ggsw_carry);
        ctxt.ct_vec_mantissa = res.ct_vec_mantissa;
        ctxt.ct_vec_exponent = res.ct_vec_exponent;
    }

    pub fn full_propagate_mantissa_increase_exponent_if_necessary(&self, ctxt: &mut Ciphertext) {
        let len = ctxt.ct_vec_mantissa.len();
        for i in 0..len {
            self.propagate_mantissa_increase_exponent_if_necessary(ctxt, i);
        }
    }

    pub fn clean_degree(&self, ctxt: &mut Ciphertext) {
        self.reduce_noise_sign(ctxt);
        self.full_propagate_exponent(&mut ctxt.ct_vec_exponent);
        self.full_propagate_mantissa_increase_exponent_if_necessary(ctxt)
    }

    /// Propagate the carry of the 'index' block to the next one.
    /// if index is equals to the MS LWE, this operation do nothing.
    /// We want to keep all the information on this LWE ( with this operation we can't create a
    /// new LWE
    pub fn propagate_mantissa_parallelized(&self, ctxt: &mut [shortint::Ciphertext], index: usize) {
        // todo!("propagate_mantissa_parallelized");
        if index < ctxt.len() - 1 {
            let (carry, msg) = rayon::join(
                || self.key.carry_extract(&ctxt[index]),
                || self.key.message_extract(&ctxt[index]),
            );
            ctxt[index] = msg;
            self.key.unchecked_add_assign(&mut ctxt[index + 1], &carry);
        }
        //TODO maybe just BS to decrease the noise ?
    }

    /// Propagate all the carries.
    pub fn full_propagate_mantissa_parallelized(&self, ctxt: &mut [shortint::Ciphertext]) {
        // todo!("full_propagate_mantissa_parallelized");
        let len = ctxt.len();
        for i in 0..len {
            self.propagate_mantissa_parallelized(ctxt, i);
        }
    }

    // TODO use the low latency propagation
    pub fn propagate_exponent_parallelized(&self, ctxt: &mut [shortint::Ciphertext], index: usize) {
        if index < ctxt.len() - 1 {
            let (carry, msg) = rayon::join(
                || self.key.carry_extract(&ctxt[index]),
                || self.key.message_extract(&ctxt[index]),
            );
            ctxt[index] = msg;
            self.key.unchecked_add_assign(&mut ctxt[index + 1], &carry);
        } else {
            self.key.message_extract_assign(&mut ctxt[index]);
        }
    }

    /// Propagate all the carries.
    /// except the msb lwe
    pub fn partial_propagate_parallelized(&self, ctxt: &mut Vec<shortint::Ciphertext>) {
        for i in 0..(ctxt.len() - 1) {
            self.propagate_exponent_parallelized(ctxt, i);
        }
    }

    /// Propagate all the carries.
    pub fn full_propagate_exponent_parallelized(&self, ctxt: &mut [shortint::Ciphertext]) {
        for i in 0..(ctxt.len()) {
            self.propagate_exponent_parallelized(ctxt, i);
        }
    }

    fn propagate_mantissa_increase_exponent_if_necessary_parallelized(
        &self,
        ctxt: &mut Ciphertext,
        index: usize,
    ) {
        if index < ctxt.ct_vec_mantissa.len() - 1 {
            let (carry, msg) = rayon::join(
                || self.key.carry_extract(&ctxt.ct_vec_mantissa[index]),
                || self.key.message_extract(&ctxt.ct_vec_mantissa[index]),
            );
            ctxt.ct_vec_mantissa[index] = msg;
            self.key
                .unchecked_add_assign(&mut ctxt.ct_vec_mantissa[index + 1], &carry);
        } else {
            self.increase_exponent_if_necessary_parallelized(ctxt);
        }
    }

    fn increase_exponent_if_necessary_parallelized(&self, ctxt: &mut Ciphertext) {
        let msg_modulus = self.wopbs_key.param.message_modulus.0 as usize;
        let car_modulus = self.wopbs_key.param.carry_modulus.0 as usize;
        let msg_space = f64::log2((msg_modulus * car_modulus) as f64) as usize;
        let len = ctxt.ct_vec_mantissa.len();
        let (carry, msg) = rayon::join(
            || {
                self.key
                    .carry_extract(&ctxt.ct_vec_mantissa.last().unwrap())
            },
            || {
                self.key
                    .message_extract(&ctxt.ct_vec_mantissa.last().clone().unwrap())
            },
        );

        ctxt.ct_vec_mantissa[len - 1] = msg;
        let mut tmp = ctxt.clone();
        tmp.ct_vec_mantissa.push(carry.clone());
        let _ = tmp.ct_vec_mantissa.remove(0);
        self.key
            .unchecked_scalar_add_assign(&mut tmp.ct_vec_exponent[0], 1);
        let ggsw_carry = self.is_block_non_zero_ggsw_pbs_ks_cbs_parallelized(&carry, msg_space);
        let res = self.cmuxes_full_parallelized(ctxt, &tmp, &ggsw_carry);
        ctxt.ct_vec_mantissa = res.ct_vec_mantissa;
        ctxt.ct_vec_exponent = res.ct_vec_exponent;
    }

    fn increase_exponent_if_necessary_parallelized_carry(
        &self,
        ctxt: &mut Ciphertext,
        mantissa_carry: &shortint::Ciphertext,
    ) {
        let msg_modulus = self.wopbs_key.param.message_modulus.0 as usize;
        let car_modulus = self.wopbs_key.param.carry_modulus.0 as usize;
        let msg_space = (msg_modulus * car_modulus).ilog2() as usize;

        let mut tmp = ctxt.clone();
        tmp.ct_vec_mantissa.push(mantissa_carry.clone());
        let _ = tmp.ct_vec_mantissa.remove(0);
        self.key
            .unchecked_scalar_add_assign(&mut tmp.ct_vec_exponent[0], 1);
        let ggsw_carry =
            self.is_block_non_zero_ggsw_pbs_ks_cbs_parallelized(&mantissa_carry, msg_space);
        let res = self.cmuxes_full_parallelized(ctxt, &tmp, &ggsw_carry);
        ctxt.ct_vec_mantissa = res.ct_vec_mantissa;
        ctxt.ct_vec_exponent = res.ct_vec_exponent;
    }

    pub fn full_propagate_mantissa_increase_exponent_if_necessary_parallelized(
        &self,
        ctxt: &mut Ciphertext,
    ) {
        let len = ctxt.ct_vec_mantissa.len();
        for i in 0..len {
            self.propagate_mantissa_increase_exponent_if_necessary_parallelized(ctxt, i);
        }
    }

    pub fn clean_degree_parallelized(&self, ctxt: &mut Ciphertext) {
        // todo!("clean_degree_parallelized");
        self.reduce_noise_sign(ctxt);
        // let now = std::time::Instant::now();
        self.full_propagate_exponent_parallelized(&mut ctxt.ct_vec_exponent);
        // let elapsed = now.elapsed();
        // println!("elapsed exponent propagate: {elapsed:?}");

        // let now = std::time::Instant::now();
        self.full_propagate_mantissa_increase_exponent_if_necessary_parallelized(ctxt);
        // let elapsed = now.elapsed();
        // println!("elapsed mantissa propagate: {elapsed:?}");
    }
}
