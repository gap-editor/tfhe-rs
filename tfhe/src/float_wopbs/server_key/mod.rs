//! Module with the definition of the ServerKey.
//!
//! This module implements the generation of the server public key, together with all the
//! available homomorphic integer operations.
#[cfg(test)]
mod tests;

use crate::core_crypto::commons::parameters::{CiphertextCount, DeltaLog, LweCiphertextCount};
use crate::core_crypto::commons::traits::*;
use crate::core_crypto::entities::*;
use crate::float_wopbs::ciphertext::Ciphertext;
use crate::float_wopbs::client_key::{float_to_uint, uint_to_float, ClientKey};
use crate::shortint::ciphertext::Degree;
use crate::shortint::wopbs::WopbsLUTBase;
use crate::core_crypto::commons::parameters;
use crate::shortint::ciphertext::MaxDegree;
use crate::shortint::ciphertext::NoiseLevel;
use serde::{Deserialize, Serialize};
use crate::shortint;


/// Error returned when the carry buffer is full.
pub use crate::shortint::CheckError;

/// A structure containing the server public key.
///
/// The server key is generated by the client and is meant to be published: the client
/// sends it to the server so it can compute homomorphic integer circuits.
#[derive(Serialize, Deserialize, Clone)]
pub struct ServerKey {
    pub key: shortint::server_key::ServerKey,
    pub wopbs_key: shortint::wopbs::WopbsKey,
}

impl ServerKey {
    /// Generates a server key.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::float::parameters::PARAM_MESSAGE_4_16_BITS;
    /// use tfhe::float::{ClientKey, ServerKey};
    ///
    /// // Generate the client key:
    /// let cks = ClientKey::new(PARAM_MESSAGE_4_16_BITS);
    ///
    /// // Generate the server key:
    /// let sks = ServerKey::new(&cks);
    /// ```
    pub fn new(cks: &ClientKey) -> ServerKey {
        // It should remain just enough space to add a carry
        let max =
            (cks.key.parameters.message_modulus().0 - 1) * cks.key.parameters.carry_modulus().0 - 1;
        let sks =
            shortint::server_key::ServerKey::new_with_max_degree(&cks.key, MaxDegree(max));
        // TODO DANGER
        let wopbs_key =
            shortint::wopbs::WopbsKey::new_wopbs_key_only_for_wopbs(&cks.key, &sks);
        ServerKey {
            key: sks,
            wopbs_key,
        }
    }

    /// Creates a ServerKey from an already generated shortint::ServerKey.
    pub fn from_shortint(
        cks: &ClientKey,
        mut key: crate::shortint::server_key::ServerKey,
        wopbs_key: crate::shortint::wopbs::WopbsKey,
    ) -> ServerKey {
        // It should remain just enough space add a carry
        let max =
            (cks.key.parameters.message_modulus().0 - 1) * cks.key.parameters.carry_modulus().0 - 1;
        key.max_degree = MaxDegree(max);
        ServerKey { key, wopbs_key }
    }

    pub fn create_lut<F: Fn(f64) -> f64>(&self, ct: &mut Ciphertext, f: F) -> Vec<Vec<u64>> {
        let log_msg_mod = f64::log2(self.wopbs_key.param.message_modulus.0 as f64).ceil() as u64;
        let bit_mantissa = ct.nb_bit_mantissa;
        let bit_exponent = ct.nb_bit_exponent;
        let len_vec = ct.ct_vec_float.len();

        let e_min = ct.e_min;
        let total_bit = (bit_exponent + bit_mantissa) as u64 + 1;
        let mut lut_len = 1 << total_bit;
        if 1 << total_bit < self.wopbs_key.param.polynomial_size.0 as u64 {
            lut_len = self.wopbs_key.param.polynomial_size.0;
        }
        let mut vec_lut = vec![vec![0; lut_len]; len_vec];

        for value in 0..1 << total_bit {
            let float = uint_to_float(value, e_min, bit_mantissa, bit_exponent);
            let mut encoded_float = float_to_uint(f(float), e_min, bit_mantissa, bit_exponent);
            for lut in vec_lut.iter_mut() {
                lut[value as usize] =
                    (encoded_float % (1 << log_msg_mod)) * ((1_u64 << 63) / (1 << log_msg_mod));
                encoded_float >>= log_msg_mod;
            }
        }
        vec_lut
    }

    pub fn create_bivariate_lut<F: Fn(f64, f64) -> f64>(
        &self,
        ct: &mut Ciphertext,
        f: F,
    ) -> Vec<Vec<u64>> {
        let log_msg_mod = f64::log2(self.wopbs_key.param.message_modulus.0 as f64).ceil() as u64;
        let bit_mantissa = ct.nb_bit_mantissa;
        let bit_exponent = ct.nb_bit_exponent;
        let len_vec = ct.ct_vec_float.len();

        let e_min = ct.e_min;
        let total_bit = 2 * ((bit_exponent + bit_mantissa) as u64 + 1);
        let mut lut_len = 1 << total_bit;
        if 1 << total_bit < self.wopbs_key.param.polynomial_size.0 as u64 {
            lut_len = self.wopbs_key.param.polynomial_size.0;
        }
        let mut vec_lut = vec![vec![0; lut_len]; len_vec];

        for value in 0..1 << total_bit {
            let value_1 = value % (1 << (total_bit / 2));
            let value_2 = value >> (total_bit / 2);
            let float_1 = uint_to_float(value_1, e_min, bit_mantissa, bit_exponent);
            let float_2 = uint_to_float(value_2, e_min, bit_mantissa, bit_exponent);
            let float = f(float_1, float_2);
            let mut encoded_float = float_to_uint(float, e_min, bit_mantissa, bit_exponent);
            for lut in vec_lut.iter_mut() {
                lut[value as usize] =
                    (encoded_float % (1 << log_msg_mod)) * ((1_u64 << 63) / (1 << log_msg_mod));
                encoded_float >>= log_msg_mod;
            }
        }
        vec_lut
    }

    pub fn create_trivariate_lut<F: Fn(f64, f64, f64) -> f64>(
        &self,
        ct: &mut Ciphertext,
        f: F,
    ) -> Vec<Vec<u64>> {
        let log_msg_mod = f64::log2(self.wopbs_key.param.message_modulus.0 as f64).ceil() as u64;
        let bit_mantissa = ct.nb_bit_mantissa;
        let bit_exponent = ct.nb_bit_exponent;
        let len_vec = ct.ct_vec_float.len();

        let e_min = ct.e_min;
        let total_bit = 3 * ((bit_exponent + bit_mantissa) as u64 + 1);

        let mut lut_len = 1 << total_bit;
        if 1 << total_bit < self.wopbs_key.param.polynomial_size.0 as u64 {
            lut_len = self.wopbs_key.param.polynomial_size.0;
        }
        let mut vec_lut = vec![vec![0; lut_len]; len_vec];

        for value in 0..1 << total_bit {
            let value_1 = value % (1 << (total_bit / 3));
            let value_2 = (value >> (total_bit / 3))  % (1 << (total_bit / 3));
            let value_3 = (value >> (2 * total_bit / 3))  % (1 << (total_bit / 3));
            let float_1 = uint_to_float(value_1, e_min, bit_mantissa, bit_exponent);
            let float_2 = uint_to_float(value_2, e_min, bit_mantissa, bit_exponent);
            let float_3 = uint_to_float(value_3, e_min, bit_mantissa, bit_exponent);
            let float = f(float_1, float_2, float_3);
            let mut encoded_float = float_to_uint(float, e_min, bit_mantissa, bit_exponent);
            for lut in vec_lut.iter_mut() {
                lut[value as usize] =
                    (encoded_float % (1 << log_msg_mod)) * ((1_u64 << 63) / (1 << log_msg_mod));
                encoded_float >>= log_msg_mod;
            }
        }
        vec_lut
    }

    pub fn wop_pbs_bivariate(
        &self,
        sks: &ServerKey,
        ct_in_1: &mut Ciphertext,
        ct_in_2: &mut Ciphertext,
        lut: &[Vec<u64>],
    ) -> Ciphertext {
        let mut vec_ct = vec![ct_in_1, ct_in_2];
        self.wop(sks, &mut vec_ct, lut)
    }

    pub fn wop_pbs_trivariate(
        &self,
        sks: &ServerKey,
        ct_in_1: &mut Ciphertext,
        ct_in_2: &mut Ciphertext,
        ct_in_3: &mut Ciphertext,
        lut: &[Vec<u64>],
    ) -> Ciphertext {
        let mut vec_ct = vec![ct_in_1, ct_in_2, ct_in_3];
        self.wop(sks, &mut vec_ct, lut)
    }

    pub fn wop_pbs(&self, sks: &ServerKey, ct_in: &mut Ciphertext, lut: &[Vec<u64>]) -> Ciphertext {
        let mut vec_ct = vec![ct_in];
        self.wop(sks, &mut vec_ct, lut)
    }

    fn wop(
        &self,
        // TODO DANGER
        _sks: &ServerKey,
        vec_ct_in: &mut [&mut Ciphertext],
        lut: &[Vec<u64>],
    ) -> Ciphertext {
        let total_bits_extracted = vec_ct_in.iter().fold(0usize, |acc, ct_in| {
            acc + ct_in.nb_bit_mantissa + ct_in.nb_bit_exponent + 1
        });

        let extract_bits_output_lwe_size = self
            .wopbs_key
            .wopbs_server_key
            .key_switching_key
            .output_key_lwe_dimension()
            .to_lwe_size();

        let mut vec_lwe = LweCiphertextList::new(
            0u64,
            extract_bits_output_lwe_size,
            LweCiphertextCount(total_bits_extracted),
            self.wopbs_key.param.ciphertext_modulus,
        );

        let mut bits_extracted_so_far = 0;

        // Extraction of each bit for each block
        for ct_in in vec_ct_in.iter_mut() {
            let mut remain_bit_to_extract = ct_in.nb_bit_mantissa + ct_in.nb_bit_exponent + 1;
            let mut nb_bit_to_extract = f64::log2((self.key.message_modulus.0) as f64) as usize;
            for block in ct_in.ct_vec_float.iter_mut() {
                let delta = (1_usize << 63) / (block.message_modulus.0 * block.carry_modulus.0);
                let delta_log = DeltaLog(f64::log2(delta as f64) as usize);
                if nb_bit_to_extract > remain_bit_to_extract {
                    nb_bit_to_extract = remain_bit_to_extract;
                    remain_bit_to_extract = 0;
                } else {
                    remain_bit_to_extract -= nb_bit_to_extract
                }

                // Fill in reverse to have the proper order for float ops
                bits_extracted_so_far += nb_bit_to_extract;
                let extract_from_bit = total_bits_extracted - bits_extracted_so_far;
                let extract_to_bit = extract_from_bit + nb_bit_to_extract;

                // TODO DANGER
                let tmp = self
                    .wopbs_key
                    .extract_bits(delta_log, block, parameters::ExtractedBitsCount(nb_bit_to_extract));

                let mut lwe_sub_list = vec_lwe.get_sub_mut(extract_from_bit..extract_to_bit);
                lwe_sub_list.as_mut().copy_from_slice(tmp.as_ref());
            }
        }
        let out_ct_count = lut.len();
        let lut = WopbsLUTBase::from_vec(
            lut.iter().flatten().cloned().collect(),
            CiphertextCount(out_ct_count),
        );
        // TODO DANGER
        let mut vec_ct_out = self
            .wopbs_key
            .circuit_bootstrapping_vertical_packing(&lut, &vec_lwe);

        let mut ct_vec_out_float: Vec<crate::shortint::Ciphertext> = vec![];
        for (block_mantissa, result_ct) in
            vec_ct_in[0].ct_vec_float.iter().zip(vec_ct_out.drain(..))
        {
            ct_vec_out_float.push(crate::shortint::Ciphertext::new(
                result_ct,
                Degree(block_mantissa.message_modulus.0 - 1),
                NoiseLevel::NOMINAL,
                block_mantissa.message_modulus,
                block_mantissa.carry_modulus,
                crate::shortint::PBSOrder::KeyswitchBootstrap,
            ));
        }

        Ciphertext {
            ct_vec_float: ct_vec_out_float,
            nb_bit_mantissa: vec_ct_in[0].nb_bit_mantissa,
            nb_bit_exponent: vec_ct_in[0].nb_bit_exponent,
            key_id_vec: vec_ct_in[0].key_id_vec.clone(),
            e_min: vec_ct_in[0].e_min,
        }
    }
}
